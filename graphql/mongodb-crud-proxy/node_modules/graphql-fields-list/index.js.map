{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * ISC License\n *\n * Copyright (c) 2018-present, Mykhailo Stadnyk <mikhus@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\nimport {\n    ArgumentNode,\n    DirectiveNode,\n    SelectionNode,\n    FragmentDefinitionNode,\n    GraphQLResolveInfo,\n    FieldNode,\n} from 'graphql';\n\n/**\n * Pre-compiled wildcard replacement regexp\n *\n * @type {RegExp}\n */\nconst RX_AST = /\\*/g;\n\n/**\n * Fragment item type\n *\n * @access public\n */\nexport interface FragmentItem {\n    [name: string]: FragmentDefinitionNode;\n}\n\n/**\n * Field names transformation map interface\n *\n * @access public\n */\nexport interface FieldNamesMap {\n    [name: string]: string;\n}\n\n/**\n * fieldsList options argument interface\n *\n * @access public\n */\nexport interface FieldsListOptions {\n    /**\n     * Path to a tree branch which should be mapped during fields extraction\n     * @type {string}\n     */\n    path?: string;\n\n    /**\n     * Transformation rules which should be used to re-name field names\n     * @type {FieldNamesMap}\n     */\n    transform?: FieldNamesMap;\n\n    /**\n     * Flag which turns on/off GraphQL directives checks on a fields\n     * and take them into account during fields analysis\n     * @type {boolean}\n     */\n    withDirectives?: boolean;\n\n    /**\n     * Flag which turns on/off whether to return the parent fields or not\n     * @type {boolean}\n     */\n    keepParentField?: boolean;\n\n    /**\n     * Fields skip rule patterns. Usually used to ignore part of request field\n     * subtree. For example if query looks like:\n     * profiles {\n     *   id\n     *   users {\n     *     name\n     *     email\n     *     password\n     *   }\n     * }\n     * and you doo n not care about users, it can be done like:\n     * fieldsList(info, { skip: ['users'] }); // or\n     * fieldsProjection(info, { skip: ['users.*'] }); // more obvious notation\n     *\n     * If you want to skip only exact fields, it can be done as:\n     * fieldsMap(info, { skip: ['users.email', 'users.password'] })\n     */\n    skip?: string[];\n}\n\n/**\n * Type definition for variables values map\n *\n * @access public\n */\nexport interface VariablesValues {\n    [name: string]: any;\n}\n\n/**\n * Fields projection object, where keys are dot-notated field paths\n * ended-up with a truthy (1) value\n *\n * @access public\n */\nexport interface FieldsProjection {\n    [name: string]: 1;\n}\n\n/**\n * Traverse query nodes tree options arg interface\n * @access private\n */\ninterface TraverseOptions {\n    fragments: FragmentItem;\n    vars: any;\n    withVars?: boolean;\n}\n\n/**\n * Retrieves a list of nodes from a given selection (either fragment or\n * selection node)\n *\n * @param {FragmentDefinitionNode | FieldNode} selection\n * @return {ReadonlyArray<FieldNode>}\n * @access private\n */\nfunction getNodes(\n    selection: FragmentDefinitionNode | SelectionNode,\n): ReadonlyArray<SelectionNode> {\n    return (((((selection || {}) as any).selectionSet || {}) as any)\n        .selections || []) as ReadonlyArray<SelectionNode>;\n}\n\n/**\n * Checks if a given directive name and value valid to return a field\n *\n * @param {string} name\n * @param {boolean} value\n * @return boolean\n * @access private\n */\nfunction checkValue(name: string, value: boolean): boolean {\n    return name === 'skip'\n        ? !value\n        : name === 'include' ? value : true\n    ;\n}\n\n/**\n * Checks if a given directive arg allows to return field\n *\n * @param {string} name - directive name\n * @param {ArgumentNode} arg\n * @param {VariablesValues} vars\n * @return {boolean}\n * @access private\n */\nfunction verifyDirectiveArg(\n    name: string,\n    arg: ArgumentNode,\n    vars: VariablesValues\n): boolean {\n    switch (arg.value.kind) {\n        case 'BooleanValue':\n            return checkValue(name, arg.value.value);\n        case 'Variable':\n            return checkValue(name, vars[arg.value.name.value]);\n    }\n\n    return true;\n}\n\n/**\n * Checks if a given directive allows to return field\n *\n * @param {DirectiveNode} directive\n * @param {VariablesValues} vars\n * @return {boolean}\n * @access private\n */\nfunction verifyDirective(\n    directive: DirectiveNode,\n    vars: VariablesValues,\n): boolean {\n    const directiveName: string = directive.name.value;\n\n    if (!~['include', 'skip'].indexOf(directiveName)) {\n        return true;\n    }\n\n    let args: any[] = directive.arguments as any[];\n\n    if (!(args && args.length)) {\n        args = [];\n    }\n\n    for (const arg of args) {\n        if (!verifyDirectiveArg(directiveName, arg, vars)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks if a given list of directives allows to return field\n *\n * @param {ReadonlyArray<DirectiveNode>} directives\n * @param {VariablesValues} vars\n * @return {boolean}\n * @access private\n */\nfunction verifyDirectives(\n    directives: ReadonlyArray<DirectiveNode> | undefined,\n    vars: VariablesValues,\n): boolean {\n    if (!directives || !directives.length) {\n        return true;\n    }\n\n    vars = vars || {};\n\n    for (const directive of directives) {\n        if (!verifyDirective(directive, vars)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks if a given node is inline fragment and process it,\n * otherwise does nothing and returns false.\n *\n * @param {SelectionNode} node\n * @param {*} root\n * @param {*} skip\n * @param {TraverseOptions} opts\n */\nfunction verifyInlineFragment(\n    node: SelectionNode,\n    root: any,\n    opts: TraverseOptions,\n    skip: any,\n) {\n    if (node.kind === 'InlineFragment') {\n        const nodes = getNodes(node);\n\n        nodes.length && traverse(nodes, root, opts, skip);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Builds skip rules tree from a given skip option argument\n *\n * @param {string[]} skip - skip option arguments\n * @return {any} - skip rules tree\n */\nfunction skipTree(skip: string[]) {\n    const tree: any = {};\n\n    for (const pattern of skip) {\n        const props = pattern.split('.');\n        let propTree = tree;\n\n        for (let i = 0, s = props.length; i < s; i++) {\n            const prop = props[i];\n            const all = props[i + 1] === '*';\n\n            if (!propTree[prop]) {\n                propTree[prop] = i === s - 1 || all ? true : {};\n                all && i++;\n            }\n\n            propTree = propTree[prop];\n        }\n    }\n\n    return tree;\n}\n\n/**\n *\n * @param node\n * @param skip\n */\nfunction verifySkip(node: string, skip: any) {\n    if (!skip) {\n        return false;\n    }\n\n    if (skip[node]) {\n        return skip[node];\n    }\n\n    // lookup through wildcard patterns\n    let nodeTree: any = false;\n    const patterns = Object.keys(skip).filter(pattern => ~pattern.indexOf('*'));\n\n    for (const pattern of patterns) {\n        const rx: RegExp = new RegExp(pattern.replace(RX_AST, '.*'));\n\n        if (rx.test(node)) {\n            nodeTree = skip[pattern];\n\n            if (nodeTree === true) {\n                break;\n            }\n        }\n    }\n\n    return nodeTree;\n}\n\n/**\n * Traverses recursively given nodes and fills-up given root tree with\n * a requested field names\n *\n * @param {ReadonlyArray<FieldNode>} nodes\n * @param {*} root\n * @param {TraverseOptions} opts\n * @param {*} skip\n * @return {*}\n * @access private\n */\nfunction traverse(\n    nodes: ReadonlyArray<SelectionNode>,\n    root: any,\n    opts: TraverseOptions,\n    skip: any,\n): any {\n    for (const node of nodes) {\n        if (opts.withVars && !verifyDirectives(node.directives, opts.vars)) {\n            continue;\n        }\n\n        if (verifyInlineFragment(node, root, opts, skip)) {\n            continue;\n        }\n\n        const name = (node as FieldNode).name.value;\n\n        if (opts.fragments[name]) {\n            traverse(getNodes(opts.fragments[name]), root, opts, skip);\n            continue;\n        }\n\n        const nodes = getNodes(node);\n        const nodeSkip = verifySkip(name, skip);\n\n        if (nodeSkip !== true) {\n            root[name] = root[name] || (nodes.length ? {} : false);\n            nodes.length && traverse(\n                nodes,\n                root[name],\n                opts,\n                nodeSkip,\n            );\n        }\n    }\n\n    return root;\n}\n\n/**\n * Retrieves and returns a branch from a given tree by a given path\n *\n * @param {*} tree\n * @param {string} [path]\n * @return {*}\n * @access private\n */\nfunction getBranch(tree: any, path?: string): any {\n    if (!path) {\n        return tree;\n    }\n\n    for (const fieldName of path.split('.')) {\n        if (!tree[fieldName]) {\n            return {};\n        }\n\n        tree = tree[fieldName];\n    }\n\n    return tree;\n}\n\n/**\n * Verifies if a given info object is valid. If valid - returns\n * proper FieldNode object for given resolver node, otherwise returns null.\n *\n * @param {GraphQLResolveInfo} info\n * @return {FieldNode | null}\n * @access private\n */\nfunction verifyInfo(info: GraphQLResolveInfo): SelectionNode | null {\n    if (!info) {\n        return null;\n    }\n\n    if (!info.fieldNodes && (info as any).fieldASTs) {\n        (info as any).fieldNodes = (info as any).fieldASTs;\n    }\n\n    if (!info.fieldNodes) {\n        return null;\n    }\n\n    return verifyFieldNode(info);\n}\n\n/**\n * Verifies if a proper fieldNode existing on given info object\n *\n * @param {GraphQLResolveInfo} info\n * @return {FieldNode | null}\n * @access private\n */\nfunction verifyFieldNode(info: GraphQLResolveInfo): FieldNode | null {\n    const fieldNode: FieldNode | undefined = info.fieldNodes.find(\n        (node: FieldNode) =>\n            node && node.name && node.name.value === info.fieldName\n    );\n\n    if (!(fieldNode && fieldNode.selectionSet)) {\n        return null;\n    }\n\n    return fieldNode;\n}\n\n/**\n * Parses input options and returns prepared options object\n *\n * @param {FieldsListOptions} options\n * @return {FieldsListOptions}\n * @access private\n */\nfunction parseOptions(options?: FieldsListOptions) {\n    if (!options) {\n        return {};\n    }\n\n    if (options.withDirectives === undefined) {\n        options.withDirectives = true;\n    }\n\n    return options;\n}\n\n/**\n * Extracts and returns requested fields tree\n *\n * @param {GraphQLResolveInfo} info\n * @param {FieldsListOptions} options\n * @access public\n */\nexport function fieldsMap(\n    info: GraphQLResolveInfo,\n    options?: FieldsListOptions,\n) {\n    const fieldNode: SelectionNode | null = verifyInfo(info);\n\n    if (!fieldNode) {\n        return {};\n    }\n\n    const { path, withDirectives, skip } = parseOptions(options);\n    const tree = traverse(getNodes(fieldNode), {}, {\n            fragments: info.fragments,\n            vars: info.variableValues,\n            withVars: withDirectives,\n        },\n        skipTree(skip || []),\n    );\n\n    return getBranch(tree, path);\n}\n\n/**\n * Extracts list of selected fields from a given GraphQL resolver info\n * argument and returns them as an array of strings, using the given\n * extraction options.\n *\n * @param {GraphQLResolveInfo} info - GraphQL resolver info object\n * @param {FieldsListOptions} [options] - fields list extraction options\n * @return {string[]} - array of field names\n * @access public\n */\nexport function fieldsList(\n    info: GraphQLResolveInfo,\n    options: FieldsListOptions = {},\n) {\n    return Object.keys(fieldsMap(info, options))\n        .map((field: string) => (options.transform || {})[field] || field);\n}\n\n/**\n * Combines parent path with child name to fully-qualified dot-notation path\n * of a child\n *\n * @param {string} parent\n * @param {string} child\n * @return {string}\n * @access private\n */\nfunction toDotNotation(parent: string, child: string) {\n    return `${parent ? parent + '.' : ''}${child}`\n}\n\n/**\n * Extracts projection of selected fields from a given GraphQL resolver info\n * argument and returns flat fields projection object, where keys are object\n * paths in dot-notation form.\n *\n * @param {GraphQLResolveInfo} info - GraphQL resolver info object\n * @param {FieldsListOptions} options - fields list extraction options\n * @return {FieldsProjection} - fields projection object\n * @access public\n */\nexport function fieldsProjection(\n    info: GraphQLResolveInfo,\n    options?: FieldsListOptions,\n): FieldsProjection {\n    const tree = fieldsMap(info, options);\n    const stack: any[] = [];\n    const map: FieldsProjection = {};\n    const transform = (options || {}).transform || {};\n\n    stack.push({ node: '', tree });\n\n    while (stack.length) {\n        for (const j of Object.keys(stack[0].tree)) {\n            if (stack[0].tree[j]) {\n                const nodeDottedName = toDotNotation(stack[0].node, j);\n                stack.push({\n                    node: nodeDottedName,\n                    tree: stack[0].tree[j],\n                });\n\n                if (options?.keepParentField) map[nodeDottedName] = 1;\n\n                continue;\n            }\n\n            let dotName = toDotNotation(stack[0].node, j);\n\n            if (transform[dotName]) {\n                dotName = transform[dotName];\n            }\n\n            map[dotName] = 1;\n        }\n        stack.shift();\n    }\n\n    return map;\n}\n\n// istanbul ignore next\nif (process.env['IS_UNIT_TEST']) {\n    // noinspection JSUnusedGlobalSymbols\n    Object.assign(module.exports, {\n        getNodes,\n        traverse,\n        getBranch,\n        verifyDirectives,\n        verifyDirective,\n        verifyDirectiveArg,\n        checkValue,\n        verifyInfo,\n        verifyFieldNode,\n        verifyInlineFragment,\n        verifySkip,\n        parseOptions,\n        toDotNotation,\n    });\n}\n"]}